---
title: 有关现代优化算法的笔记
date: 2021-08-14 22:55:18
tags: 算法
---

#### 题目

已知100个目标的经度、纬度

| 纬度    | 经度    | 纬度    | 经度    | 纬度    | 经度    | 纬度    |
| ------- | ------- | ------- | ------- | ------- | ------- | ------- |
| 53.7121 | 46.3253 | 28.2753 | 46.3253 | 28.2753 | 30.3313 | 6.9348  |
| 56.5432 | 22.7891 | 23.1045 | 22.7891 | 23.1045 | 10.1584 | 12.4819 |
| 20.1050 | 26.4951 | 22.1221 | 26.4951 | 22.1221 | 31.4847 | 8.9640  |
| 26.2418 | 28.9836 | 25.9879 | 28.9836 | 25.9879 | 38.4722 | 20.1731 |
| 28.2694 | 36.4863 | 29.7284 | 36.4863 | 29.7284 | 0.9718  | 28.1477 |
| 8.9586  | 10.5597 | 15.1178 | 10.5597 | 15.1178 | 50.2111 | 10.2944 |
| 8.1519  | 0.1215  | 18.8726 | 0.1215  | 18.8726 | 48.2077 | 16.8889 |
| 31.9499 | 47.4134 | 23.7783 | 47.4134 | 23.7783 | 41.8671 | 3.5667  |
| 43.5474 | 30.8165 | 13.4595 | 30.8165 | 13.4595 | 27.7133 | 5.0706  |
| 23.9222 | 12.7938 | 15.7307 | 12.7938 | 15.7307 | 4.9568  | 8.3669  |
| 21.5051 | 6.2070  | 5.1442  | 6.2070  | 5.1442  | 49.2430 | 16.7044 |
| 17.1168 | 9.4402  | 3.9200  | 9.4402  | 3.9200  | 11.5812 | 14.5677 |
| 52.1181 | 24.4509 | 6.5634  | 24.4509 | 6.5634  | 26.7213 | 28.5667 |
| 37.5848 | 24.4654 | 3.1644  | 24.4654 | 3.1644  | 0.7775  | 6.9576  |
| 14.4703 | 3.1616  | 4.2428  | 3.1616  | 4.2428  | 18.5245 | 14.3598 |
| 58.6849 | 56.5089 | 13.7090 | 56.5089 | 13.7090 | 52.5211 | 15.7957 |
| 38.4300 | 8.9983  | 23.6440 | 8.9983  | 23.6440 | 50.1156 | 23.7816 |
| 13.7909 | 23.0624 | 8.4319  | 23.0624 | 8.4319  | 19.9857 | 5.7902  |
| 40.8801 | 18.6635 | 6.7436  | 18.6635 | 6.7436  | 52.8423 | 27.2880 |
| 39.9494 | 10.1121 | 27.2662 | 10.1121 | 27.2662 | 28.7812 | 27.6659 |
| 8.0831  | 53.7989 | 0.2199  | 53.7989 | 0.2199  | 33.6490 | 0.3980  |
| 1.3496  | 19.3635 | 17.6622 | 19.3635 | 17.6622 | 36.9545 | 23.0265 |
| 15.7320 | 44.0398 | 16.2635 | 44.0398 | 16.2635 | 39.7139 | 28.4203 |
| 6.9909  | 24.6543 | 19.6057 | 24.6543 | 19.6057 | 36.9980 | 24.3992 |
| 4.1591  | 23.9876 | 9.4030  | 23.9876 | 9.4030  | 41.1084 | 27.7149 |

我方有一个基地，经度和纬度为(70,40)。假设我方飞机的速度为1000km/h。我方派一架飞机从基地出发，侦察完所有目标，再返回原来的基地。在每一个目标的侦察时间不计，求该架飞机所花费的最短时间。

#### 模拟退火算法

```matlab
clc, clear, close all
sj0=load('data12_1.txt');
x=sj0(:,[1:2:7]); x=x(:);
y=sj0(:,[2:2:8]); y=y(:);
sj=[x y]; d1=[70,40]; 
xy=[d1;sj;d1]; sj=xy*pi/180; %角度化成弧度
d=zeros(102); %距离矩阵d初始化
for i=1:101
   for j=i+1:102
       d(i,j)=6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*...
           cos(sj(j,2))+sin(sj(i,2))*sin(sj(j,2)));
   end
end
d=d+d';
path=[];long=inf; %巡航路径及长度初始化
for j=1:1000  %求较好的初始解
    path0=[1,1+randperm(100),102]; temp=0;
    for i=1:101
        temp=temp+d(path0(i),path0(i+1));
    end
    if temp<long
        path=path0; long=temp;
    end
end
e=0.1^30;L=20000;at=0.999;T=1;
for k=1:L  %退火过程
    c=2+floor(100*rand(1,2));  %产生新解
    c=sort(c); c1=c(1);c2=c(2);
    %计算代价函数值的增量
    df=d(path(c1-1),path(c2))+d(path(c1),path(c2+1))-...
        d(path(c1-1),path(c1))-d(path(c2),path(c2+1));
    if df<0 %接受准则
        path=[path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long=long+df;
    elseif exp(-df/T)>=rand
        path=[path(1:c1-1),path(c2:-1:c1),path(c2+1:102)]; long=long+df;
    end
    T=T*at;
    if T<e
        break;
    end
end
path, long % 输出巡航路径及路径长度
xx=xy(path,1); yy=xy(path,2);
plot(xx,yy,'-*') %画出巡航路径
```

![模拟退火算法画出的路线图](https://z3.ax1x.com/2021/08/14/f6vqZn.jpg)

#### 遗传算法

```matlab
clc,clear, close all
sj0=load('data12_1.txt');
x=sj0(:,1:2:8); x=x(:);
y=sj0(:,2:2:8); y=y(:);
sj=[x y]; d1=[70,40]; 
xy=[d1;sj;d1]; sj=xy*pi/180;  %单位化成弧度
d=zeros(102); %距离矩阵d的初始值
for i=1:101
  for j=i+1:102
      d(i,j)=6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*...
          cos(sj(j,2))+sin(sj(i,2))*sin(sj(j,2)));
  end
end
d=d+d'; w=50; g=100; %w为种群的个数，g为进化的代数
for k=1:w  %通过改良圈算法选取初始种群
    c=randperm(100); %产生1，...，100的一个全排列  
    c1=[1,c+1,102]; %生成初始解
    for t=1:102 %该层循环是修改圈 
        flag=0; %修改圈退出标志
    for m=1:100
      for n=m+2:101
        if d(c1(m),c1(n))+d(c1(m+1),c1(n+1))<...
                d(c1(m),c1(m+1))+d(c1(n),c1(n+1))
           c1(m+1:n)=c1(n:-1:m+1);  flag=1; %修改圈
        end
      end
    end
   if flag==0
      J(k,c1)=1:102; break %记录下较好的解并退出当前层循环
   end
   end
end
J(:,1)=0; J=J/102; %把整数序列转换成[0,1]区间上的实数，即转换成染色体编码
for k=1:g  %该层循环进行遗传算法的操作 
    A=J; %交配产生子代A的初始染色体
    c=randperm(w); %产生下面交叉操作的染色体对 
    for i=1:2:w  
        F=2+floor(100*rand(1)); %产生交叉操作的地址
        temp=A(c(i),[F:102]); %中间变量的保存值
        A(c(i),[F:102])=A(c(i+1),[F:102]); %交叉操作
        A(c(i+1),F:102)=temp;  
    end
    by=[];  %为了防止下面产生空地址，这里先初始化
while ~length(by)
    by=find(rand(1,w)<0.1); %产生变异操作的地址
end
B=A(by,:); %产生变异操作的初始染色体
for j=1:length(by)
   bw=sort(2+floor(100*rand(1,3)));  %产生变异操作的3个地址
   B(j,:)=B(j,[1:bw(1)-1,bw(2)+1:bw(3),bw(1):bw(2),bw(3)+1:102]); %交换位置
end
   G=[J;A;B]; %父代和子代种群合在一起
   [SG,ind1]=sort(G,2); %把染色体翻译成1，...,102的序列ind1
   num=size(G,1); long=zeros(1,num); %路径长度的初始值
   for j=1:num
       for i=1:101
           long(j)=long(j)+d(ind1(j,i),ind1(j,i+1)); %计算每条路径长度
       end
   end
     [slong,ind2]=sort(long); %对路径长度按照从小到大排序
     J=G(ind2(1:w),:); %精选前w个较短的路径对应的染色体
end
path=ind1(ind2(1),:), flong=slong(1)  %解的路径及路径长度
xx=xy(path,1);yy=xy(path,2);
plot(xx,yy,'-o') %画出路径
```

![遗传算法画出的路线图](https://z3.ax1x.com/2021/08/14/f6x9sJ.jpg)

#### 改进的遗传算法

```matlab
tic  %计时开始
clc,clear, close all
sj0=load('data12_1.txt'); 
x=sj0(:,1:2:8); x=x(:);
y=sj0(:,2:2:8); y=y(:);
sj=[x y]; d1=[70,40]; 
xy=[d1;sj;d1]; sj=xy*pi/180;  %单位化成弧度
d=zeros(102); %距离矩阵d的初始值
for i=1:101
  for j=i+1:102
      d(i,j)=6370*acos(cos(sj(i,1)-sj(j,1))*cos(sj(i,2))*...
             cos(sj(j,2))+sin(sj(i,2))*sin(sj(j,2)));
  end
end
d=d+d'; w=50; g=100; %w为种群的个数，g为进化的代数
rand('state',sum(clock)); %初始化随机数发生器
for k=1:w  %通过改良圈算法选取初始种群
    c=randperm(100); %产生1，...，100的一个全排列  
    c1=[1,c+1,102]; %生成初始解
    for t=1:102 %该层循环是修改圈 
        flag=0; %修改圈退出标志
    for m=1:100
      for n=m+2:101
        if d(c1(m),c1(n))+d(c1(m+1),c1(n+1))<...
                d(c1(m),c1(m+1))+d(c1(n),c1(n+1))
           c1(m+1:n)=c1(n:-1:m+1);  flag=1; %修改圈
        end
      end
    end
   if flag==0
      J(k,c1)=1:102; break %记录下较好的解并退出当前层循环
   end
   end
end
J(:,1)=0; J=J/102; %把整数序列转换成[0,1]区间上的实数，即转换成染色体编码
for k=1:g  %该层循环进行遗传算法的操作 
    A=J; %交配产生子代A的初始染色体
    for i=1:2:w
        ch1(1)=rand; %混沌序列的初始值
        for j=2:50
            ch1(j)=4*ch1(j-1)*(1-ch1(j-1)); %产生混沌序列
        end
        ch1=2+floor(100*ch1); %产生交叉操作的地址
        temp=A(i,ch1); %中间变量的保存值
        A(i,ch1)=A(i+1,ch1); %交叉操作
        A(i+1,ch1)=temp;
    end
    by=[];  %为了防止下面产生空地址，这里先初始化
while ~length(by)
    by=find(rand(1,w)<0.1); %产生变异操作的地址
end
num1=length(by); B=J(by,:); %产生变异操作的初始染色体
ch2=rand;  %产生混沌序列的初始值
for t=2:2*num1 
       ch2(t)=4*ch2(t-1)*(1-ch2(t-1)); %产生混沌序列
end
for j=1:num1
   bw=sort(2+floor(100*rand(1,2)));  %产生变异操作的2个地址
   B(j,bw)=ch2([j,j+1]); %bw处的两个基因发生了变异
end
   G=[J;A;B]; %父代和子代种群合在一起
   [SG,ind1]=sort(G,2); %把染色体翻译成1，...,102的序列ind1
   num2=size(G,1); long=zeros(1,num2); %路径长度的初始值
   for j=1:num2
       for i=1:101
           long(j)=long(j)+d(ind1(j,i),ind1(j,i+1)); %计算每条路径长度
       end
   end
     [slong,ind2]=sort(long); %对路径长度按照从小到大排序
     J=G(ind2(1:w),:); %精选前w个较短的路径对应的染色体
end
path=ind1(ind2(1),:), flong=slong(1)  %解的路径及路径长度
toc  %计时结束
xx=xy(path,1);yy=xy(path,2);
plot(xx,yy,'-o') %画出路径
```

![改进的遗传算法画出的路线图](https://z3.ax1x.com/2021/08/14/f6zP1S.jpg)
